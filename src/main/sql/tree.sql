create table article
(
    id    bigint generated by default as identity
        constraint article_pk primary key,
    title varchar not null
);

create table comment
(
    id         bigint generated by default as identity
        constraint comment_pk primary key,
    body       varchar not null,
    parent_id  bigint
        constraint parent_fk references comment,
    article_id bigint
        constraint article_fk references article,
    constraint fk_check
        check (((parent_id IS NULL) AND (article_id IS NOT NULL)) OR ((parent_id IS NOT NULL) AND (article_id IS NULL)))
);

create index comment_idx_article_id on comment (article_id);

create index comment_idx_parent_id on comment (parent_id);

-- select root comments and 1st level sub-comments
with comment_article as (select *
                         from comment c1
                         where c1.article_id is not null
                         union all
                         select c2.id, c2.body, c2.parent_id, c1.article_id
                         from "comment" c2
                         join comment c1 on c2.parent_id = c1.id
                         where c1.article_id is not null)
select *
from comment_article
where article_id = 1;

-- add article_id to all comments
with recursive comment_article as (select *
                                   from "comment" c
                                   where c.article_id is not null
                                   union all
                                   select c.id, c.body, c.parent_id, ca.article_id
                                   from comment c
                                   join comment_article ca on c.parent_id = ca.id)
select *
from comment_article ca
-- where ca.article_id = 1
order by ca.id;

-- add depth to comments
with recursive comment_article
                   as (select c.id, c.body, c.parent_id, 0 depth
                       from "comment" c
                       where c.parent_id is null
                       union all
                       select c.id, c.body, c.parent_id, ca.depth + 1
                       from comment_article ca
                       join comment c on c.parent_id = ca.id)
select *
from comment_article ca
-- where ca.depth = 2
order by ca.id;

-- test generating article names
with series as (select ('article ' || gs) title from generate_series(3, 10) as gs)
select *
from series;

-- insert generated rows into table article
insert INTO article(title)
select ('article ' || gs) title
from generate_series(3, 10) as gs;

-- add rank to top level comments
select *, rank() over (partition by article_id order by id) rank
from comment
where article_id is not null
order by article_id, rank;

-- add rank to replies
select *, rank() over (partition by parent_id order by id) rank
from comment
where parent_id is not null
order by parent_id, rank;

-- add rank to all comments
select *,
       case
           when article_id is not null then rank() over (partition by article_id order by id)
           else rank() over (partition by parent_id order by id)
           end rank
from comment
order by article_id, parent_id, rank;

-- add path to all comments
with recursive comment_path
                   as (select *, ARRAY [article_id, rank() over (partition by article_id order by id)] path
                       from comment
                       where article_id is not null
                       union all
                       select c.*, (cp.path || rank() over (partition by c.parent_id order by c.id))
                       from comment c
                       join comment_path cp on c.parent_id = cp.id)
select id, body, parent_id, article_id, path
from comment_path
-- where path = ARRAY[1::bigint, 3]
order by path;

-- select row and all children
with recursive comment_children
                   as (select *
                       from comment
                       where id = 214
                       union all
                       select c.*
                       from comment c
                       join comment_children cc on c.parent_id = cc.id)
select *
from comment_children;

-- delete row and all children
with recursive comment_children
                   as (select id
                       from comment
                       where id = 214
                       union all
                       select c.id
                       from comment c
                       join comment_children cc on c.parent_id = cc.id)
delete
from comment c
    using comment_children cc
where c.id = cc.id;

-- select 100 random articles
with count_rows as (select count(*) from article),
     article_rows as (select *, (row_number() over ()) row from article),
     random_rows as (select floor(random() * (select * from count_rows) + 1) row from generate_series(1, 100))
select id, title
from random_rows rr
join article_rows ar on rr.row = ar.row;

-- insert 100 top level comments
with count_rows as (select count(*) from article),
     article_rows as (select *, (row_number() over ()) row from article),
     random_rows as (select floor(random() * (select * from count_rows) + 1) row from generate_series(1, 100))
insert
into comment(body, article_id)
select ('comment ' || id || '.x') body, id article_id
from (select id
      from random_rows ri
      join article_rows ar on ri.row = ar.row) i;

-- select 1000 random top level comments
with comment_rows as (select *, (row_number() over ()) row from comment where article_id is not null),
     count_rows as (select count(*) from comment_rows),
     random_rows as (select floor(random() * (select * from count_rows) + 1) row from generate_series(1, 1000))
select id, body, parent_id, article_id
from random_rows rr
join comment_rows cr on rr.row = cr.row;

-- insert 1000 top level replies to top level comments
with comment_rows as (select *, (row_number() over ()) row from comment where article_id is not null),
     count_rows as (select count(*) from comment_rows),
     random_rows as (select floor(random() * (select * from count_rows) + 1) row from generate_series(1, 1000))
insert
into comment(body, parent_id)
select (body || '.x') body, id parent_id
from random_rows rr
join comment_rows cr on rr.row = cr.row;

-- select 10000 random comments of depth 1
with recursive desired_depth as (select 1),
               comment_depth as (select c.*, 0 depth
                                 from "comment" c
                                 where c.parent_id is null
                                 union all
                                 select c.*, cd.depth + 1
                                 from comment_depth cd
                                 join comment c on c.parent_id = cd.id
                                 -- stop iteration early
                                 where cd.depth < (select * from desired_depth)),
               comment_rows as (select *, (row_number() over ()) row
                                from comment_depth
                                where depth = (select * from desired_depth)),
               count_rows as (select count(*) from comment_rows),
               random_rows as (select floor(random() * (select * from count_rows) + 1) row
                               from generate_series(1, 10000))
select id, body, parent_id, article_id
from random_rows rr
join comment_rows cr on rr.row = cr.row;

-- insert 10_000 comments of depth 1
with recursive desired_depth as (select 1),
               comment_depth as (select c.*, 0 depth
                                 from "comment" c
                                 where c.parent_id is null
                                 union all
                                 select c.*, cd.depth + 1
                                 from comment_depth cd
                                 join comment c on c.parent_id = cd.id
                                     -- stop iteration early
                                 where cd.depth < (select * from desired_depth)),
               comment_rows as (select *, (row_number() over ()) row
                                from comment_depth
                                where depth = (select * from desired_depth)),
               count_rows as (select count(*) from comment_rows),
               random_rows as (select floor(random() * (select * from count_rows) + 1) row
                               from generate_series(1, 10000))
insert
into comment(body, parent_id)
select (body || '.x') body, id parent_id
from random_rows rr
join comment_rows cr on rr.row = cr.row;

-- insert 100_000 comments of depth 2
with recursive desired_depth as (select 2),
               comment_depth as (select c.*, 0 depth
                                 from "comment" c
                                 where c.parent_id is null
                                 union all
                                 select c.*, cd.depth + 1
                                 from comment_depth cd
                                 join comment c on c.parent_id = cd.id
                                     -- stop iteration early
                                 where cd.depth < (select * from desired_depth)),
               comment_rows as (select *, (row_number() over ()) row
                                from comment_depth
                                where depth = (select * from desired_depth)),
               count_rows as (select count(*) from comment_rows),
               random_rows as (select floor(random() * (select * from count_rows) + 1) row
                               from generate_series(1, 100000))
insert
into comment(body, parent_id)
select (body || '.x') body, id parent_id
from random_rows rr
join comment_rows cr on rr.row = cr.row;

-- update body from path
with recursive comment_path
                   as (select *, ARRAY [article_id, rank() over (partition by article_id order by id)] path
                       from comment
                       where article_id is not null
                       union all
                       select c.*, (cp.path || rank() over (partition by c.parent_id order by c.id))
                       from comment c
                       join comment_path cp on c.parent_id = cp.id)
update comment c
set body = 'comment ' || array_to_string(cp.path, '.')
from comment_path cp
where c.id = cp.id;

-- count direct children
select count(*) childcount
from comment
where parent_id = 223;

-- count all children
with recursive comment_children
                   as (select *
                       from comment
                       where parent_id = 223
                       union all
                       select c.*
                       from comment c
                       join comment_children cc on c.parent_id = cc.id)
select count(*) childcount
from comment_children;

-- delete article and all comments
with recursive
    comment_children
        as (select id
            from comment
            where article_id = 1
            union all
            select c.id
            from comment c
            join comment_children cc on c.parent_id = cc.id),
    delete_comments as (delete
        from comment c
            using comment_children cc
            where c.id = cc.id)
delete
from article
where id = 1;
